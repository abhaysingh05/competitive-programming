{
	"Matrix Exponentiation": {
		"prefix": "matExp",
		"body": [
			"vector<vector<ll>> matMultiply(vector<vector<ll>> &matA, vector<vector<ll>> &matB, ll p = mod) {",
			"    ll n1 = matA.size();",
			"    ll m1 = matA[0].size();",
			"    ll n2 = matB.size();",
			"    ll m2 = matB[0].size();",
			"    vector<vector<ll>> ans(n1, vector<ll>(m2, 0));",
			"    for (ll i = 0; i < n1; i++) {",
			"        for (ll j = 0; j < m2; j++) {",
			"            for (ll k = 0; k < m1; k++) {",
			"                ans[i][j] = (ans[i][j] + ((matA[i][k]) * matB[k][j]) % p) % p;",
			"            }",
			"        }",
			"    }",
			"    return ans;",
			"}",
			"vector<vector<ll>> matExp(vector<vector<ll>> mat, ll y, ll p = mod) {",
			"    ll n = mat.size();",
			"    vector<vector<ll>> res(n, vector<ll>(n, 0));",
			"    for (ll i = 0; i < n; i++) res[i][i] = 1;",
			"    while (y > 0) {",
			"        if (y & 1)",
			"            res = (matMultiply(res, mat, p));",
			"        y = y >> 1;",
			"        mat = matMultiply(mat, mat, p);",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Matrix Exponentiation"
	},
	"Matrix Multiplication": {
		"prefix": "matMultiply",
		"body": [
			"vector<vector<ll>> matMultiply(vector<vector<ll>> &matA, vector<vector<ll>> &matB, ll p = mod) {",
			"    ll n1 = matA.size();",
			"    ll m1 = matA[0].size();",
			"    ll n2 = matB.size();",
			"    ll m2 = matB[0].size();",
			"    vector<vector<ll>> ans(n1, vector<ll>(m2, 0));",
			"    for (ll i = 0; i < n1; i++) {",
			"        for (ll j = 0; j < m2; j++) {",
			"            for (ll k = 0; k < m1; k++) {",
			"                ans[i][j] = (ans[i][j] + ((matA[i][k]) * matB[k][j]) % p) % p;",
			"            }",
			"        }",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "Matrix Multiplication"
	},
	"Fenwick_Tree": {
		"prefix": "fenwicktree",
		"body": [
			"template<typename T>",
			"struct fenwick_tree {",
			"    static int highest_bit(unsigned x) {",
			"        return x == 0 ? -1 : 31 - __builtin_clz(x);",
			"    }",
			"",
			"    int tree_n = 0;",
			"    T tree_sum = T();",
			"    vector<T> tree;",
			"",
			"    fenwick_tree(int n = -1) {",
			"        if (n >= 0)",
			"            init(n);",
			"    }",
			"",
			"    void init(int n) {",
			"        tree_n = n;",
			"        tree_sum = T();",
			"        tree.assign(tree_n + 1, T());",
			"    }",
			"",
			"    // O(n) initialization of the Fenwick tree.",
			"    template<typename T_array>",
			"    void build(const T_array &initial) {",
			"        assert(int(initial.size()) == tree_n);",
			"        tree_sum = T();",
			"",
			"        for (int i = 1; i <= tree_n; i++) {",
			"            tree[i] = initial[i - 1];",
			"            tree_sum += initial[i - 1];",
			"",
			"            for (int k = (i & -i) >> 1; k > 0; k >>= 1)",
			"                tree[i] += tree[i - k];",
			"        }",
			"    }",
			"",
			"    // index is in [0, tree_n).",
			"    void update(int index, const T &change) {",
			"        assert(0 <= index && index < tree_n);",
			"        tree_sum += change;",
			"",
			"        for (int i = index + 1; i <= tree_n; i += i & -i)",
			"            tree[i] += change;",
			"    }",
			"",
			"    // Returns the sum of the range [0, count).",
			"    T query(int count) const {",
			"        count = min(count, tree_n);",
			"        T sum = T();",
			"",
			"        for (int i = count; i > 0; i -= i & -i)",
			"            sum += tree[i];",
			"",
			"        return sum;",
			"    }",
			"",
			"    // Returns the sum of the range [start, tree_n).",
			"    T query_suffix(int start) const {",
			"        return tree_sum - query(start);",
			"    }",
			"",
			"    // Returns the sum of the range [a, b).",
			"    T query(int a, int b) const {",
			"        return query(b) - query(a);",
			"    }",
			"",
			"    // Returns the element at index a in O(1) amortized across every index. Equivalent to query(a, a + 1).",
			"    T get(int a) const {",
			"        assert(0 <= a && a < tree_n);",
			"        int above = a + 1;",
			"        T sum = tree[above];",
			"        above -= above & -above;",
			"",
			"        while (a != above) {",
			"            sum -= tree[a];",
			"            a -= a & -a;",
			"        }",
			"",
			"        return sum;",
			"    }",
			"",
			"    bool set(int index, T value) {",
			"        assert(0 <= index && index < tree_n);",
			"        T current = get(index);",
			"",
			"        if (current == value)",
			"            return false;",
			"",
			"        update(index, value - current);",
			"        return true;",
			"    }",
			"",
			"    // Returns the largest p in `[0, tree_n]` such that `query(p) <= sum`. Returns -1 if no such p exists (`sum < 0`).",
			"    // Can be used as an ordered set/multiset on indices in `[0, tree_n)` by using the tree as a 0/1 or frequency array:",
			"    // `set(index, 1)` is equivalent to insert(index). `update(index, +1)` is equivalent to multiset.insert(index).",
			"    // `set(index, 0)` or `update(index, -1)` are equivalent to erase(index).",
			"    // `get(index)` provides whether index is present or not, or the count of index (if multiset).",
			"    // `query(index)` provides the count of elements < index.",
			"    // `find_last_prefix(k)` finds the k-th smallest element (0-indexed). Returns `tree_n` for `sum >= set.size()`.",
			"    int find_last_prefix(T sum) const {",
			"        if (sum < T())",
			"            return -1;",
			"",
			"        int prefix = 0;",
			"",
			"        for (int k = highest_bit(tree_n); k >= 0; k--)",
			"            if (prefix + (1 << k) <= tree_n && tree[prefix + (1 << k)] <= sum) {",
			"                prefix += 1 << k;",
			"                sum -= tree[prefix];",
			"            }",
			"",
			"        return prefix;",
			"    }",
			"};"
		],
		"description": "Fenwick_Tree"
	},
	"basicStart": {
		"prefix": "smain",
		"body": [
			"#include <bits/stdc++.h>",
			"typedef long long ll;",
			"using namespace std;",
			"",
			"// const int M = 1e9 + 7;",
			"// const int N = 1e7 + 10;",
			"",
			"",
			"",
			"int main()",
			"{",
			"    $0",
			"    return 0;",
			"}"
		],
		"description": "Log output to console"
	},
	"Competitive_Programming": {
		"prefix": "cforces",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define ff first",
			"#define ss second",
			"#define pb push_back",
			"#define all(x) x.begin(), x.end()",
			"#define int long long",
			"const int INF = (int)1e9;",
			"const int mod = INF + 7;",
			"/**************************************************************************************/",
			"",
			"void runCase(int &testCase) {",
			"    // cout << \"#Case \" << testCase << \": \\n\";",
			"",
			"    ${1:// Your code here}$0",
			"}",
			"",
			"int32_t main() {",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"",
			"    int tests = 1;",
			"    cin >> tests;",
			"    for (int i = 1; i <= tests; i++) runCase(i);",
			"",
			"    return 0;",
			"}"
		],
		"description": "Competitive_Programming"
	},
	"anotherCP-snippet": {
		"prefix": "codeforces",
		"body": [
			"#include <algorithm>",
			"#include <array>",
			"#include <bitset>",
			"#include <cassert>",
			"#include <chrono>",
			"#include <cmath>",
			"#include <cstdint>",
			"#include <cstring>",
			"#include <functional>",
			"#include <iomanip>",
			"#include <iostream>",
			"#include <map>",
			"#include <numeric>",
			"#include <queue>",
			"#include <random>",
			"#include <set>",
			"#include <stack>",
			"#include <vector>",
			"using namespace std;",
			"",
			"void run_case(int64_t &tttt) {",
			"    // cout << \"#Case \" << tttt << \": \";",
			"",
			"    ${1://Your code here}",
			"}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"",
			"    int64_t tests = 1;",
			"    cin >> tests;",
			"",
			"    for (int64_t i = 1; i <= tests; i++)",
			"        run_case(i);",
			"}"
		],
		"description": "Print to console"
	},
	"antherCP-snippet": {
		"prefix": "bestcp",
		"body": [
			"// ******************************* Header Files ***************************//",
			"#include<bits/stdc++.h>",
			"#include<ext/pb_ds/assoc_container.hpp>",
			"#include<ext/pb_ds/tree_policy.hpp>",
			"#pragma GCC optimize(\"Ofast,no-stack-protector,fast-math\",3)",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"// ****************************** Macros **************************",
			"#define nline \"\\n\"",
			"#define ff first",
			"#define ss second",
			"#define pb push_back",
			"#define arrs(arr) sizeof(arr)/sizeof(arr[0]);",
			"#define ppb pop_back",
			"#define mp make_pair",
			"#define p push",
			"#define re reverse",
			"#define maxele max_element",
			"#define minele min_element",
			"#define mt make_tuple",
			"#define lb lower_bound",
			"#define ub upper_bound",
			"#define loop(i,m,n) for(int i = m; i < n; i++)",
			"#define rloop(i,m,n) for(int i = m; i >= n;i--)",
			"#define er erase",
			"#define mem memset(a,(b),sizeof(a))",
			"#define acc accumulate",
			"#define fbo(x) find_by_order(x)",
			"#define sz(x)   ((int)(x).size())",
			"#define ll long long",
			"#define get(i,m) get<i>(m)",
			"#define oby(x) order_of_key(x)",
			"#define lld long  double",
			"#define ull unsigned long long",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).end(),(x).begin()",
			"#define set_bits __builtin_popcountll",
			"#define debug(x)  cerr << #x << \" = \";  print(x);  cerr << nline;",
			"#define debug2(x,y) cerr << #x << \" = \"; print(x); cerr << #y << \" = \"; print(y); cerr << nline;",
			"",
			"",
			"//**************************** Constants ***********************************//",
			"",
			"const lld pi = 3.141592653589793238;",
			"const ll INF = 1e18;",
			"const ll mod = 1e9 + 7;",
			"",
			"// ********************************* Typedef ********************************//",
			"",
			"typedef pair<ll,ll> pll;",
			"typedef vector<ll> vll;",
			"typedef vector<string> vst;",
			"typedef vector<char> vc;",
			"typedef priority_queue<int> pq;",
			"typedef priority_queue<ll> pqll;",
			"typedef priority_queue<int,vector<int>,greater<int>> pqm;",
			"typedef priority_queue<ll,vector<ll>,greater<ll>> pqmll;",
			"typedef vector<pair<string,char>> vpsc;",
			"typedef vector<pair<char,string>> vpcs;",
			"typedef vector<pll> vpll;",
			"typedef vector<string> vs;",
			"typedef deque<int> dq;",
			"typedef multiset<int> ms;",
			"typedef multiset<ll> msll;",
			"typedef multimap<int,int> mp;",
			"typedef multimap<ll,ll> mpll;",
			"typedef deque<ll> dqll;",
			"typedef stack<int> st;",
			"typedef stack<ll> stll;",
			"typedef unordered_map<ll,ll> umll;",
			"typedef map<ll,ll> mll;",
			"typedef set<ll> sll;",
			"typedef unordered_set<ll,ll> usll;",
			"",
			"",
			"// ******************************* Custom Safe Hash ********************************** //",
			"struct custom_hash",
			"{",
			"static uint64_t splitmix64(uint64_t x)",
			"    {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    size_t operator()(uint64_t x) const",
			"    {",
			"        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};",
			"template <typename T1, typename T2>",
			"using safe_map = unordered_map<T1, T2, custom_hash>;",
			"",
			"// ******************************* Policy Based DS ********************************** //",
			"template<class T>",
			"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update> ;",
			"template<typename T>",
			"using ordered_multiset = tree<T, null_type,less_equal<T>, rb_tree_tag,tree_order_statistics_node_update>;",
			"template<class key, class value, class cmp = std::less<key>>",
			"using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;",
			"",
			"// ********************** Some Utility Functions ********************************//",
			"template<typename T>",
			"void _print(T &&t)  { cout << t << \"\\n\"; }",
			"void debugarr(ll arr[], ll n){cerr << \"[ \"; loop(i,0,n) cerr << arr[i] << \" \";cerr << \"]\"; cerr << nline;}",
			"template<typename T>",
			"void printvec(vector<T>v){ll n=v.size();loop(i,0,n)cout<<v[i]<<\" \";cout<<\"\\n\";}",
			"template<typename T>",
			"ll sumvec(vector<T>v){ll n=v.size();ll s=0;loop(i,0,n)s+=v[i];return s;}",
			"",
			"// ***************************  Operators Overloading **********************************//",
			"template<typename T1, typename T2>",
			"istream& operator>>(istream &istream, pair<T1, T2> &p) { return (istream >> p.first >> p.second); }",
			"template<typename T>",
			"istream& operator>>(istream &istream, vector<T> &v){for (auto &it : v)cin >> it;return istream;}",
			"template<typename T1, typename T2> ",
			"ostream& operator<<(ostream &ostream, const pair<T1, T2> &p) { return (ostream << p.first << \" \" << p.second); }",
			"template<typename T>",
			"ostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }",
			"",
			"// *************************************** Debugging **************************************** //",
			"",
			"template<class T>void print(T x) {cerr << x << \" \";}",
			"template<class T, class V> void print(pair<T , V> x)",
			"{print(x.ff); cerr << ':'; print(x.ss);}",
			"template<class T>void print(vector<T> &a) {cerr << '[' << ' ';for(auto x : a){print(x);cerr << ' ';}cerr << ']';}",
			"template<class T>void print(set<T> &a){cerr << '[' << ' ';for(auto x : a){print(x);cerr << ' ';}cerr << ']';}",
			"template<class T>void print(set<T,greater<T>> &a){cerr << '[' << ' ';for(auto x : a){print(x);cerr << ' ';}cerr << ']';}",
			"template<class T>void print(multiset<T> &a){cerr << '[' << ' ';for(auto x : a){print(x);cerr << ' ';}cerr << ']';}",
			"template<class T>void print(multiset<T,greater<T>> &a){cerr << '[' << ' ';for(auto x : a){print(x);cerr << ' ';}cerr << ']';}",
			"template<class T> void print(unordered_set<T> &a){cerr << '[' << ' ';for(auto x : a){ print(x);cerr << ' ';}cerr << ']';}",
			"template<class T, class V>void print(vector<pair<T, V>> &a){cerr << '[' << ' ';for(auto x : a){print(x.ff);cerr << \":\";print(x.ss); cerr << ' ';}cerr << ']';}",
			"template <class T, class V>void print(map <T, V> &a){cerr << \"[ \";for (auto i : a){print(i);cerr << \" \"; }cerr << \"]\";}",
			"template <class T, class V>void print(unordered_map <T, V> &a){cerr << \"[ \";for (auto i : a){print(i);cerr << \" \";}cerr << \"]\";}",
			"template <class T>void print(vector<vector<T>> &a){ cerr << \"[ \";for (auto i : a){print(i);cerr << \" \";}cerr << \"]\";}",
			"// ********************************** Some Commmonly Used Functions ********************************* //",
			"ll GCD(ll a, ll b){while (b) { a %= b;swap(a, b);} return a;}",
			"ll LCM(ll a,ll b) {return ((ll) a * b) / GCD(a,b);}",
			"bool sorta(const pair<int,int> &a,const pair<int,int> &b){return (a.second < b.second);}",
			"ll moduloMultiplication(ll a,ll b,ll mod){ll res = 0;a %= mod;while (b){if (b & 1)res = (res + a) % mod;b >>= 1;}return res;}",
			"ll powermod(ll x, ll y, ll p){ll res = 1;x = x % p;if (x == 0) return 0;while (y > 0){if (y & 1)res = (res*x) % p;y = y>>1;x = (x*x) % p;}return res;}",
			"bool sortd(const pair<int,int> &a,const pair<int,int> &b){return (a.second > b.second);}",
			"string decToBinary(int n){string s=\"\";int i = 0;while (n > 0) {s =to_string(n % 2)+s;n = n / 2;i++;}return s;}",
			"ll binaryToDecimal(string n){string num = n;ll dec_value = 0;int base = 1;int len = num.length();for(int i = len - 1; i >= 0; i--){if (num[i] == '1')dec_value += base;base = base * 2;}return dec_value;}",
			"bool isPrime(ll n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}",
			"bool isPowerOfTwo(int n){if(n==0)return false;return (ceil(log2(n)) == floor(log2(n)));}",
			"bool isPerfectSquare(ll x){if (x >= 0) {ll sr = sqrt(x);return (sr * sr == x);}return false;}",
			"",
			"// ******************************** Main Solve Function ******************************* //",
			"// const int N = 1e7 + 10;",
			"",
			"void Solution() ",
			"{",
			"\t$1",
			"}",
			"",
			"// *********************************  Main Function **************************************//",
			"int main()",
			"{",
			"    judge();",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"",
			"    int t =1;",
			"    cin >> t;",
			"    while(t--)",
			"    {",
			"        Solution();",
			"    }",
			"",
			"    return 0;",
			"}"
		],
		"description": "start of the program"
	},
	"Binary to Decimal": {
		"prefix": "binaryToDecimal",
		"body": [
			"int64_t binaryToDecimal(string n)",
			"{",
			"    string num = n;",
			"    int64_t dec_value = 0;",
			"    int base = 1;",
			"    int len = num.length();",
			"    for (int i = len - 1; i >= 0; i--)",
			"    {",
			"        if (num[i] == '1')",
			"            dec_value += base;",
			"        base = base * 2;",
			"    }",
			"    return dec_value;",
			"}"
		],
		"description": "Binary to Decimal"
	},
	"Binary Exponentiation": {
		"prefix": "binExp",
		"body": [
			"int64_t binExp(int64_t x, int64_t y, int64_t p)",
			"{",
			"    int64_t res = 1;",
			"    x = x % p;",
			"    if (x == 0)",
			"        return 0;",
			"    while (y > 0)",
			"    {",
			"        if (y & 1)",
			"            res = (res * x) % p;",
			"        y = y >> 1;",
			"        x = (x * x) % p;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Binary Exponentiation"
	},
	"Decimal to Binary": {
		"prefix": "decToBinary",
		"body": [
			"string decToBinary(int n)",
			"{",
			"    string s = \"\";",
			"    int i = 0;",
			"    while (n > 0)",
			"    {",
			"        s = to_string(n % 2) + s;",
			"        n = n / 2;",
			"        i++;",
			"    }",
			"    return s;",
			"}"
		],
		"description": "Decimal to Binary"
	},
	"Greatest common Divisor": {
		"prefix": "gcd",
		"body": [
			"int64_t gcd(int64_t a, int64_t b)",
			"{",
			"    while (b)",
			"    {",
			"        a %= b;",
			"        swap(a, b);",
			"    }",
			"    return a;",
			"}"
		],
		"description": "Greatest common Divisor"
	},
	"Check Perfect Square": {
		"prefix": "isPerfectSquare",
		"body": [
			"bool isPerfectSquare(int64_t x)",
			"{",
			"    if (x >= 0)",
			"    {",
			"        int64_t sr = sqrt(x);",
			"        return (sr * sr == x);",
			"    }",
			"    return false;",
			"}"
		],
		"description": "Check Perfect Square"
	},
	"Check Power of 2": {
		"prefix": "isPowerOfTwo",
		"body": [
			"bool isPowerOfTwo(int x) {",
			"    if (x == 0) return false;",
			"    int64_t n = x;",
			"    return (n & (n - 1)) == 0;",
			"}"
		],
		"description": "Check Power of 2"
	},
	"Check Prime Number": {
		"prefix": "isPrime",
		"body": [
			"bool isPrime(int64_t n)",
			"{",
			"    if (n <= 1)",
			"        return false;",
			"    if (n <= 3)",
			"        return true;",
			"    if (n % 2 == 0 || n % 3 == 0)",
			"        return false;",
			"    for (int i = 5; i * i <= n; i = i + 6)",
			"        if (n % i == 0 || n % (i + 2) == 0)",
			"            return false;",
			"    return true;",
			"}"
		],
		"description": "Check Prime Number"
	},
	"Least common multiple": {
		"prefix": "lcm",
		"body": [
			"int64_t lcm(int64_t a, int64_t b)",
			"{",
			"    return ((int64_t)a * b) / __gcd(a, b);",
			"}"
		],
		"description": "Least common multiple"
	},
	"Modulo Multiplication": {
		"prefix": "moduloMultiplication",
		"body": [
			"int64_t moduloMultiplication(int64_t a, int64_t b, int64_t mod)",
			"{",
			"    int64_t res = 0;",
			"    a %= mod;",
			"    while (b)",
			"    {",
			"        if (b & 1)",
			"            res = (res + a) % mod;",
			"        b >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Modulo Multiplication"
	},
	"Custom Safe Hash": {
		"prefix": "custom_hash",
		"body": [
			"struct custom_hash",
			"{",
			"    static uint64_t splitmix64(uint64_t x)",
			"    {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    size_t operator()(uint64_t x) const",
			"    {",
			"        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"};",
			"template <typename T1, typename T2>",
			"using safe_map = unordered_map<T1, T2, custom_hash>;"
		],
		"description": "Custom Safe Hash"
	},
	"ordered-pbds-datastr": {
		"prefix": "pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"using namespace __gnu_pbds;",
			"template <class T>",
			"using _set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"// X.find_by_order(k) return iterator of kth element. 0 indexed.",
			"// X.order_of_key(k) returns count of elements strictly less than k.",
			"template <typename T>",
			"using _multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
			"template <class key, class value, class cmp = std::less<key>>",
			"using _map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;"
		],
		"description": "ordered-pbds"
	}
}